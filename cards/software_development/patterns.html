<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patterns</title>
    <link rel="stylesheet" href="../../style.css">
    <script src="../../main.js" type="module"></script>
</head>

<body>
    <main>
        <table>
            <tr>
                <td>
                    <h3>Creational patterns</h3>
                    <dl>
                        <dt>Abstract factory</dt>
                        <dd>Provide an interface for creating families of related or dependent objects without
                            specifying their
                            concrete classes.</dd>
                        <dt>Builder</dt>
                        <dd>Separate the construction of a complex object from its representation, allowing the same
                            construction
                            process to create various representations.</dd>
                        <dt>Factory method</dt>
                        <dd>Define an interface for creating a single object, but let subclasses decide which class to
                            instantiate.
                            Factory Method lets a class defer instantiation to subclasses.</dd>
                        <dt>Prototype</dt>
                        <dd>Specify the kinds of objects to create using a prototypical instance, and create new objects
                            from the
                            'skeleton' of an existing object, thus boosting performance and keeping memory footprints to
                            a minimum.
                        </dd>
                        <dt>Singleton</dt>
                        <dd>Ensure a class has only one instance, and provide a global point of access to it.</dd>
                    </dl>

                    <h3>Structural patterns</h3>
                    <dl>
                        <dt>Adapter, Wrapper, or Translator</dt>
                        <dd>Convert the interface of a class into another interface clients expect. An adapter lets
                            classes work
                            together that could not otherwise because of incompatible interfaces. The enterprise
                            integration pattern
                            equivalent is the translator.</dd>
                        <dt>Bridge</dt>
                        <dd>Decouple an abstraction from its implementation allowing the two to vary independently.</dd>
                        <dt>Composite</dt>
                        <dd>Compose objects into tree structures to represent part-whole hierarchies. Composite lets
                            clients treat
                            individual objects and compositions of objects uniformly.</dd>
                        <dt>Decorator</dt>
                        <dd>Attach additional responsibilities to an object dynamically keeping the same interface.
                            Decorators
                            provide a flexible alternative to subclassing for extending functionality.</dd>
                        <dt>Facade</dt>
                        <dd>Provide a unified interface to a set of interfaces in a subsystem. Facade defines a
                            higher-level
                            interface that makes the subsystem easier to use.</dd>
                        <dt>Flyweight</dt>
                        <dd>Use sharing to support large numbers of similar objects efficiently.</dd>
                        <dt>Proxy</dt>
                        <dd>Provide a surrogate or placeholder for another object to control access to it.</dd>
                    </dl>
                </td>
                <td style="padding-left: 5px;">
                    <h3>Behavioral patterns</h3>
                    <dl>
                        <dt>Chain of responsibility</dt>
                        <dd>Avoid coupling the sender of a request to its receiver by giving more than one object a
                            chance to handle
                            the request. Chain the receiving objects and pass the request along the chain until an
                            object handles
                            it.</dd>
                        <dt>Command</dt>
                        <dd>Encapsulate a request as an object, thereby allowing for the parameterization of clients
                            with different
                            requests, and the queuing or logging of requests. It also allows for the support of undoable
                            operations.
                        </dd>
                        <dt>Interpreter</dt>
                        <dd>Given a language, define a representation for its grammar along with an interpreter that
                            uses the
                            representation to interpret sentences in the language.</dd>
                        <dt>Iterator</dt>
                        <dd>Provide a way to access the elements of an aggregate object sequentially without exposing
                            its underlying
                            representation.</dd>
                        <dt>Mediator</dt>
                        <dd>Define an object that encapsulates how a set of objects interact. Mediator promotes loose
                            coupling by
                            keeping objects from referring to each other explicitly, and it allows their interaction to
                            vary
                            independently.</dd>
                        <dt>Memento</dt>
                        <dd>Without violating encapsulation, capture and externalize an object's internal state allowing
                            the object
                            to be restored to this state later.</dd>
                        <dt>Observer or Publish/subscribe</dt>
                        <dd>Define a one-to-many dependency between objects where a state change in
                            one object
                            results in all its dependents being notified and updated automatically.</dd>
                        <dt>State</dt>
                        <dd>Allow an object to alter its behavior when its internal state changes. The object will
                            appear to change
                            its class.</dd>
                        <dt>Strategy</dt>
                        <dd>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy
                            lets the
                            algorithm vary independently from clients that use it.</dd>
                        <dt>Template method</dt>
                        <dd>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses.
                            Template method
                            lets subclasses redefine certain steps of an algorithm without changing the algorithm's
                            structure.</dd>
                        <dt>Visitor</dt>
                        <dd>Represent an operation to be performed on instances of a set of classes. Visitor lets a new
                            operation be
                            defined without changing the classes of the elements on which it operates.</dd>
                    </dl>
                </td>
            </tr>
        </table>
    </main>
</body>

</html>